import random
import itertools
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import csv

class PasswordPatternSystem:
    """Main system integrating password generation and binary pattern analysis"""
    
    def __init__(self):
        self.uppercase_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        self.lowercase_letters = 'abcdefghijklmnopqrstuvwxyz'
        self.digits = '0123456789'
    
    # ----- PART A: PASSWORD GENERATOR -----
    
    def calculate_total_passwords(self):
        """
        Calculate total possible passwords using Fundamental Counting Principle
        Format: 1 uppercase + 3 unique digits + 1 lowercase
        
        Mathematical explanation:
        - Uppercase choices: 26 letters
        - First digit: 10 choices
        - Second digit: 9 choices (must be different from first)
        - Third digit: 8 choices (must be different from first two)
        - Lowercase choices: 26 letters
        
        Total = 26 × P(10,3) × 26 = 26 × (10×9×8) × 26
        where P(10,3) is permutation of 10 digits taken 3 at a time
        """
        uppercase_count = len(self.uppercase_letters)  # 26
        lowercase_count = len(self.lowercase_letters)  # 26
        
        # Permutation for 3 unique digits from 10 digits: P(10,3) = 10!/(10-3)! = 10×9×8
        digit_permutations = 10 * 9 * 8  # 720
        
        total = uppercase_count * digit_permutations * lowercase_count
        return total  # 26 × 720 × 26 = 486,720
    
    def generate_password(self):
        """Generate a single valid password following the format rules"""
        # Select one random uppercase letter
        upper = random.choice(self.uppercase_letters)
        
        # Select 3 unique digits using random sampling without replacement
        three_digits = random.sample(self.digits, 3)
        digit_string = ''.join(three_digits)
        
        # Select one random lowercase letter
        lower = random.choice(self.lowercase_letters)
        
        # Combine all parts into final password
        password = upper + digit_string + lower
        return password
    
    def generate_multiple_passwords(self, count):
        """
        Generate multiple unique passwords
        Uses set data structure to ensure uniqueness
        """
        if count < 1 or count > 20:
            raise ValueError("Password count must be between 1 and 20")
        
        passwords = set()  # Set automatically handles uniqueness
        max_attempts = count * 100  # Prevent infinite loop
        attempts = 0
        
        # Keep generating until we have enough unique passwords
        while len(passwords) < count and attempts < max_attempts:
            new_password = self.generate_password()
            passwords.add(new_password)
            attempts += 1
        
        return list(passwords)
    
    # ----- PART B: PATTERN ANALYZER -----
    
    def count_valid_binary_strings(self, n):
        """
        Count binary strings of length n without consecutive 1s
        Uses recurrence relation: S(n) = S(n-1) + S(n-2)
        Base cases: S(0) = 1, S(1) = 2
        
        Dynamic programming approach for efficiency
        
        Explanation of recurrence:
        - S(n-1): strings ending in 0 (can append 0 or 1)
        - S(n-2): strings ending in 1 (can only append 0)
        """
        if n < 0:
            raise ValueError("n must be non-negative")
        
        # Base cases
        if n == 0:
            return 1
        if n == 1:
            return 2
        
        # Dynamic programming array to store computed values
        dp = [0] * (n + 1)
        dp[0] = 1  # Empty string or base case
        dp[1] = 2  # Strings "0" and "1"
        
        # Fill array using recurrence relation
        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]
        
        return dp[n]
    
    def generate_valid_binary_strings(self, n):
        """
        Generate all valid binary strings of length n without consecutive 1s
        Uses recursive backtracking approach
        """
        if n < 0:
            raise ValueError("n must be non-negative")
        if n == 0:
            return ['']
        
        valid_strings = []
        
        def backtrack(current_string):
            """Recursive helper function to build valid strings"""
            # Base case: string is complete
            if len(current_string) == n:
                valid_strings.append(current_string)
                return
            
            # Always can append 0
            backtrack(current_string + '0')
            
            # Can only append 1 if previous character is not 1
            if len(current_string) == 0 or current_string[-1] == '0':
                backtrack(current_string + '1')
        
        backtrack('')
        return valid_strings
    
    # ----- FILE EXPORT FUNCTIONS -----
    
    def export_passwords_to_txt(self, passwords, filename='passwords.txt'):
        """Export generated passwords to text file"""
        try:
            with open(filename, 'w') as f:
                f.write("Generated Passwords\n")
                f.write("=" * 50 + "\n\n")
                for i, pwd in enumerate(passwords, 1):
                    f.write(f"{i}. {pwd}\n")
                f.write(f"\nTotal passwords generated: {len(passwords)}\n")
                f.write(f"Total possible combinations: {self.calculate_total_passwords():,}\n")
            return True
        except Exception as e:
            print(f"Error exporting passwords: {e}")
            return False
    
    def export_binary_strings_to_csv(self, n, strings, count, filename='binary_strings.csv'):
        """Export binary string analysis to CSV file"""
        try:
            with open(filename, 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(['Binary String Analysis Results'])
                writer.writerow([])
                writer.writerow(['Length (n)', n])
                writer.writerow(['Total Valid Strings', count])
                writer.writerow([])
                
                if strings:
                    writer.writerow(['Valid Binary Strings'])
                    for string in strings:
                        writer.writerow([string])
            return True
        except Exception as e:
            print(f"Error exporting binary strings: {e}")
            return False

# ----- CONSOLE APPLICATION -----

def console_app():
    """Console-based interface for the system"""
    system = PasswordPatternSystem()
    
    print("=" * 60)
    print("PASSWORD GENERATOR AND PATTERN ANALYZER SYSTEM")
    print("=" * 60)
    print()
    
    while True:
        print("\nMain Menu:")
        print("1. Password Generator Module")
        print("2. Binary Pattern Analyzer Module")
        print("3. Exit")
        
        try:
            choice = input("\nEnter your choice (1-3): ").strip()
            
            if choice == '1':
                # Password Generator Module
                print("\n" + "=" * 60)
                print("PASSWORD GENERATOR MODULE")
                print("=" * 60)
                
                total_possible = system.calculate_total_passwords()
                print(f"\nTotal possible password combinations: {total_possible:,}")
                
                while True:
                    try:
                        count = int(input("\nEnter number of passwords to generate (1-20): "))
                        if 1 <= count <= 20:
                            break
                        print("Please enter a number between 1 and 20.")
                    except ValueError:
                        print("Invalid input. Please enter a number.")
                
                print("\nGenerating passwords...")
                passwords = system.generate_multiple_passwords(count)
                
                print(f"\n{len(passwords)} unique passwords generated:")
                print("-" * 60)
                for i, pwd in enumerate(passwords, 1):
                    print(f"{i:2}. {pwd}")
                
                # Offer export option
                export = input("\nExport to file? (y/n): ").strip().lower()
                if export == 'y':
                    filename = input("Enter filename (default: passwords.txt): ").strip()
                    if not filename:
                        filename = 'passwords.txt'
                    if system.export_passwords_to_txt(passwords, filename):
                        print(f"Successfully exported to {filename}")
                
            elif choice == '2':
                # Binary Pattern Analyzer Module
                print("\n" + "=" * 60)
                print("BINARY PATTERN ANALYZER MODULE")
                print("=" * 60)
                print("\nProblem: Count binary strings without consecutive 1s")
                
                while True:
                    try:
                        n = int(input("\nEnter string length n (non-negative integer): "))
                        if n >= 0:
                            break
                        print("Please enter a non-negative integer.")
                    except ValueError:
                        print("Invalid input. Please enter an integer.")
                
                print("\nCalculating...")
                count = system.count_valid_binary_strings(n)
                
                print(f"\nResults for n = {n}:")
                print("-" * 60)
                print(f"Number of valid binary strings: {count}")
                
                if n <= 5:
                    print("\nAll valid binary strings:")
                    strings = system.generate_valid_binary_strings(n)
                    for i, s in enumerate(strings, 1):
                        print(f"{i:2}. {s if s else '(empty)'}")
                    
                    # Offer export option
                    export = input("\nExport to CSV? (y/n): ").strip().lower()
                    if export == 'y':
                        filename = input("Enter filename (default: binary_strings.csv): ").strip()
                        if not filename:
                            filename = 'binary_strings.csv'
                        if system.export_binary_strings_to_csv(n, strings, count, filename):
                            print(f"Successfully exported to {filename}")
                else:
                    print("\n(String list not shown for n > 5 due to large output)")
                
            elif choice == '3':
                print("\nThank you for using the system!")
                break
            
            else:
                print("Invalid choice. Please enter 1, 2, or 3.")
        
        except KeyboardInterrupt:
            print("\n\nProgram interrupted. Exiting...")
            break
        except Exception as e:
            print(f"\nAn error occurred: {e}")
            print("Please try again.")

# ----- GUI APPLICATION (BONUS) -----

class PasswordPatternGUI:
    """Graphical User Interface for the system"""
    
    def __init__(self, root):
        self.root = root
        self.system = PasswordPatternSystem()
        
        self.root.title("Password Generator & Pattern Analyzer")
        self.root.geometry("800x600")
        
        # Create notebook for tabs
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Create tabs
        self.create_password_tab()
        self.create_pattern_tab()
    
    def create_password_tab(self):
        """Create the password generator tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text='Password Generator')
        
        # Title
        title = tk.Label(tab, text="Password Generator Module", 
                        font=('Arial', 16, 'bold'))
        title.pack(pady=10)
        
        # Information frame
        info_frame = tk.Frame(tab)
        info_frame.pack(pady=10)
        
        total = self.system.calculate_total_passwords()
        info_text = f"Total possible combinations: {total:,}"
        tk.Label(info_frame, text=info_text, font=('Arial', 11)).pack()
        
        # Input frame
        input_frame = tk.Frame(tab)
        input_frame.pack(pady=10)
        
        tk.Label(input_frame, text="Number of passwords (1-20):").pack(side='left', padx=5)
        self.pwd_count_var = tk.StringVar(value="10")
        tk.Entry(input_frame, textvariable=self.pwd_count_var, width=10).pack(side='left', padx=5)
        
        tk.Button(input_frame, text="Generate", command=self.generate_passwords,
                 bg='#4CAF50', fg='white', padx=20).pack(side='left', padx=5)
        tk.Button(input_frame, text="Export TXT", command=self.export_passwords,
                 bg='#2196F3', fg='white', padx=20).pack(side='left', padx=5)
        
        # Output area
        self.pwd_output = scrolledtext.ScrolledText(tab, width=70, height=20)
        self.pwd_output.pack(pady=10, padx=20)
    
    def create_pattern_tab(self):
        """Create the binary pattern analyzer tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text='Binary Pattern Analyzer')
        
        # Title
        title = tk.Label(tab, text="Binary Pattern Analyzer Module", 
                        font=('Arial', 16, 'bold'))
        title.pack(pady=10)
        
        # Description
        desc = "Count binary strings of length n without consecutive 1s"
        tk.Label(tab, text=desc, font=('Arial', 10, 'italic')).pack()
        
        # Input frame
        input_frame = tk.Frame(tab)
        input_frame.pack(pady=10)
        
        tk.Label(input_frame, text="Enter n:").pack(side='left', padx=5)
        self.n_var = tk.StringVar(value="4")
        tk.Entry(input_frame, textvariable=self.n_var, width=10).pack(side='left', padx=5)
        
        tk.Button(input_frame, text="Analyze", command=self.analyze_pattern,
                 bg='#4CAF50', fg='white', padx=20).pack(side='left', padx=5)
        tk.Button(input_frame, text="Export CSV", command=self.export_binary,
                 bg='#2196F3', fg='white', padx=20).pack(side='left', padx=5)
        
        # Output area
        self.pattern_output = scrolledtext.ScrolledText(tab, width=70, height=20)
        self.pattern_output.pack(pady=10, padx=20)
    
    def generate_passwords(self):
        """Handle password generation"""
        try:
            count = int(self.pwd_count_var.get())
            if count < 1 or count > 20:
                messagebox.showerror("Error", "Please enter a number between 1 and 20")
                return
            
            passwords = self.system.generate_multiple_passwords(count)
            
            self.pwd_output.delete(1.0, tk.END)
            self.pwd_output.insert(tk.END, "Generated Passwords:\n")
            self.pwd_output.insert(tk.END, "=" * 50 + "\n\n")
            
            for i, pwd in enumerate(passwords, 1):
                self.pwd_output.insert(tk.END, f"{i:2}. {pwd}\n")
            
            self.pwd_output.insert(tk.END, f"\nTotal generated: {len(passwords)}\n")
            
            self.current_passwords = passwords
            
        except ValueError:
            messagebox.showerror("Error", "Please enter a valid number")
    
    def export_passwords(self):
        """Export passwords to file"""
        if not hasattr(self, 'current_passwords'):
            messagebox.showwarning("Warning", "Please generate passwords first")
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if filename:
            if self.system.export_passwords_to_txt(self.current_passwords, filename):
                messagebox.showinfo("Success", f"Exported to {filename}")
    
    def analyze_pattern(self):
        """Handle binary pattern analysis"""
        try:
            n = int(self.n_var.get())
            if n < 0:
                messagebox.showerror("Error", "Please enter a non-negative integer")
                return
            
            count = self.system.count_valid_binary_strings(n)
            
            self.pattern_output.delete(1.0, tk.END)
            self.pattern_output.insert(tk.END, f"Analysis Results for n = {n}:\n")
            self.pattern_output.insert(tk.END, "=" * 50 + "\n\n")
            self.pattern_output.insert(tk.END, f"Number of valid strings: {count}\n\n")
            
            if n <= 5:
                strings = self.system.generate_valid_binary_strings(n)
                self.pattern_output.insert(tk.END, "All valid binary strings:\n")
                self.pattern_output.insert(tk.END, "-" * 50 + "\n")
                for i, s in enumerate(strings, 1):
                    self.pattern_output.insert(tk.END, f"{i:2}. {s if s else '(empty)'}\n")
                self.current_binary_data = (n, strings, count)
            else:
                self.pattern_output.insert(tk.END, "(List not shown for n > 5)")
                self.current_binary_data = (n, None, count)
            
        except ValueError:
            messagebox.showerror("Error", "Please enter a valid integer")
    
    def export_binary(self):
        """Export binary analysis to CSV"""
        if not hasattr(self, 'current_binary_data'):
            messagebox.showwarning("Warning", "Please analyze a pattern first")
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        
        if filename:
            n, strings, count = self.current_binary_data
            if self.system.export_binary_strings_to_csv(n, strings, count, filename):
                messagebox.showinfo("Success", f"Exported to {filename}")

def run_gui():
    """Launch the GUI application"""
    root = tk.Tk()
    app = PasswordPatternGUI(root)
    root.mainloop()

# ----- MAIN ENTRY POINT -----

if __name__ == "__main__":
    print("Select interface mode:")
    print("1. Console Mode")
    print("2. GUI Mode (Bonus)")
    
    while True:
        choice = input("Enter choice (1 or 2): ").strip()
        if choice == '1':
            console_app()
            break
        elif choice == '2':
            run_gui()
            break
        else:
            print("Invalid choice. Please enter 1 or 2.")